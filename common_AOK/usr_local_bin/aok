#!/bin/sh
#
#  Part of https://github.com/emkey1/AOK-Filesystem-Tools
#
#  License: MIT
#
#  Copyright (c) 2022,2023: Jacob.Lundqvist@gmail.com
#
#  Script to do various things related to the configuration of ish
#

show_help() {
    echo "Usage: $prog_name [-h] [-v] [-l login procedure]

An AOK-only script that manages iSH/AOK specific things.

Available options:

-h, --help      Print this help and exit
-v, --verbose   Be verbose
-a, --autologin Auto-login as user disable|username Now: $(display_autologin)
                disable  - Will give login prompt
                username - Will auto-login as username
-c  --continous New login prompt after logout on|off Now: $(display_continous_sessions)
-H, --hostname  Reads hostname from sync file [disable|enable] Now: $(display_hostname_method)
                disable - Use the normal hostname program,
                          always displays localhost for iOS >= 17
                enable  - Use alternate hostname program, this can either
                          use /etc/hostname for a static name, or via a
                          Shortcut read the iOS device name as iSH starts
"
    exit 0
}
# -c, --console   Console method [launch|inittab] Now: $(display_console_method)
#                 if autologin is desired, give extra param user_name
#                 launch  - launched directly from iSH via 'Launch Cmd'
#                 inittab - launched via getty in inittab once bootup
#                           has completed.

#  shellcheck disable=SC2317
destfs_is_alpine() {
    test -f /etc/alpine-release
}

#===============================================================
#
#
#       Continous login sessions
#
#
#===============================================================

change_continous_sessions() {

    error_msg "change_continous_sessions() - not implemented"
}

display_continous_sessions() {
    if [ -f "$f_logins_continous" ]; then
        echo "on"
    else
        echo "off"
    fi
}

#===============================================================
#
#
#       auto-login
#
#
#===============================================================

change_autologin() {
    uname_autologin="$1"

    if [ "$uname_autologin" = "disable" ]; then
        echo "disabling auto-login"
        rm -f "$f_login_default_user"
    else
        eval "_h=~$uname_autologin"
        # shellcheck disable=SC2154
        [ -d "$_h" ] || {
            error_msg "$uname_autologin does not seem to be a valid user on this system"
        }
        echo "$uname_autologin" >"$f_login_default_user"
        echo "Enabled auto-login for user: $uname_autologin"
    fi
}

display_autologin() {
    if [ -f "$f_login_default_user" ]; then
        cat "$f_login_default_user"
    else
        echo "$autologin_disabled"
    fi
}

#===============================================================
#
#
#       Handling console origin
#
#
#===============================================================

# lc_get() {
#     tr -d '\n' </proc/ish/defaults/launch_command | sed 's/  \+/ /g' | sed 's/"]/" ]/'
# }

# lc_set() {
#     new_cmd="$1"
#     [ -z "$new_cmd" ] && error_msg "lc_set() - no param"
#     # printf '%s' $new_cmd >/proc/ish/defaults/launch_command
#     echo "$new_cmd" >/proc/ish/defaults/launch_command
#     _lc_current="$(lc_get)"
#     [ "$_lc_current" = "$new_cmd" ] || {
#         echo "intended: >$new_cmd<"
#         echo "current:  >$_lc_current<"
#         lc_error_abort "Failed to set a launch command"
#     }
# }

# lc_set_param_join() {
#     [ -z "$1" ] && error_msg "prepare_launch_cmd() - no params"
#     _cmd="["
#     _got_one=0
#     while [ -n "$1" ]; do
#         [ "$_got_one" != 0 ] && _cmd="$_cmd,"
#         _got_one=1
#         _cmd="$_cmd \"$1\""
#         shift
#     done
#     _cmd="$_cmd ]"
#     echo "><> will use: >$_cmd<"
#     lc_set "$_cmd"
# }

# lc_restore() {
#     # echo "lc_restore()"
#     #
#     #  In case something goes wrong use this to ensure it is restored
#     #
#     # echo "><> Restoring to default launch command"

#     #  Does not use lc_set in order to prevent risk for infinite loops
#     echo "$launch_cmd_default" >/proc/ish/defaults/launch_command

#     # is safe to call even here in a "exception handler"
#     _lc_current="$(lc_get)"
#     if [ "$_lc_current" != "$launch_cmd_default" ]; then
#         echo
#         echo "ERROR: Failed to restore launch cmd!"
#         echo
#         echo "Current launch cmd: $_lc_current"
#         echo "Intended default:   $launch_cmd_default"
#         echo
#         echo "Make sure to set it manually, otherwise iSH will probably"
#         echo "fail to start!"
#         exit 1
#     fi
# }

lc_error_abort() {
    # echo "lc_error_abort()"
    msg="${1:-console mode change error!}"
    echo
    echo "***  console change error!  ***"
    echo "$msg"
    lc_restore
    echo "Launch command was reset to the default"
    lc_get
}

gettys_disable() {
    sed -i '/getty/d' /etc/inittab
    grep -q "getty" /etc/inittab && {
        lc_error_abort "Failed to clear getty lines"
    }
}

gettys_enable() {
    # some stuff i previously had in /etc/inittab
    #
    #  Before enabling either of the agetty's for pts/0 Launch cmd should be
    #  changed into this: /bin/sleep infinity
    #  If you want to use /dev/console for general output, also do
    #    rm -f /dev/console && mknod -m 222 /dev/console c 136 0
    #
    #  Using login prompt
    # tty1::respawn:/sbin/agetty pts/0 xterm-256color
    #  Autologin as selected user, be aware that logout will instantly log you in again...
    # tty1::respawn:/sbin/agetty -a root pts/0 xterm-256color
    if [ -n "$uname_autologin" ]; then
        echo "><> getty will autologin as $uname_autologin"
        _direct_login="-a $uname_autologin"
    else
        echo "><> getty will give login prompt"
        _direct_login=""
    fi
    if hostfs_is_alpine; then
        # once instead of respawn for single run
        # tty1::respawn:/sbin/agetty pts/0 xterm-256color

        # works but just one session
        getty_line="tty1::respawn:/sbin/agetty $_direct_login pts/0 xterm-256color"
        # getty_line="tty1::respawn:/sbin/agetty -a root pts/0 xterm-256color"

        #getty_line="tty1::respawn:/sbin/mingetty console"
        # getty_line="tty1::respawn:/sbin/mingetty --noissue  --autologin root pts/0"
        # getty_line="tty1::respawn:/sbin/getty 38400 pts/0"

        # no login ?
        # getty_line="tty1::respawn:/sbin/mingetty pts/0"
        # getty_line="pts0::respawn:/sbin/agetty pts/0 linux"
        # getty_line="pts0::respawn:/sbin/agetty -a root pts/0 linux"
    elif host_fs_is_debian || host_fs_is_devuan; then
        # getty_line="pts0::respawn:/sbin/agetty pts/0 xterm-256color"
        #  Autologin as selected user, be aware that logout will instantly log you in again...
        getty_line="pts0::respawn:/sbin/agetty $_direct_login pts/0 xterm-256color"
    else
        lc_error_abort "No getty known for this File System!"
    fi
    [ -z "$getty_line" ] && {
        lc_error_abort "gettys_enable() - variable getty_line unset"
    }
    (
        echo "# /usr/local/bin/aok disabled direct console, and instead activated this getty"
        echo "$getty_line"
    ) >>/etc/inittab
    grep -q "^$getty_line" /etc/inittab || {
        lc_error_abort "Failed to activate gettys"
    }
}

update_inittab() {
    it_mode="$1"

    case "$it_mode" in

    "enable")
        rm -f /dev/console && mknod -m 222 /dev/console c 136 0
        gettys_disable # First clear previous gettys
        gettys_enable
        ;;

    "disable")
        gettys_disable
        lc_error_abort "update_inittab() disable - not implemented!"
        ;;

    "") lc_error_abort "update_inittab() - no param" ;;

    *) lc_error_abort "update_inittab() - bad param: $it_mode" ;;

    esac
}

change_console_method() {
    cons_mode="$1"
    uname_autologin="$2"

    if [ -n "$uname_autologin" ]; then
        eval "_h=~$uname_autologin"
        [ -d "$_h" ] || {
            error_msg "$uname_autologin does not seem to be a valid user on this system"
        }
    fi

    case "$cons_mode" in

    "launch")
        error_msg "Currently disabled"
        ;;

    "inittab")
        error_msg "Currently disabled"
        ;;

    "display")
        lc_get
        ;;

    "") error_msg "Missing param indicating new login procedure" ;;

    *) error_msg "Bad param to change login procedure: $1" ;;

    esac
}

display_console_method() {
    #
    # Alpine
    # tty1::respawn:/sbin/agetty
    #
    # Debian
    # pts0::respawn:/sbin/agetty
    #

    _lc_current="$(lc_get)"
    if [ "$_lc_current" = "$launch_cmd_inttab" ]; then
        echo "inittab"
    else
        echo "launch"
    fi

    # # [ "/bin/login", "-f", "root"]%
    # lc_current="$(lc_get)"
    # echo "current launch cmd: $lc_current"

    # lc_set '[ "/bin/sleep", "infinity" ]'
    # lc_current="$(lc_get)"
    # echo "current launch cmd: $lc_current"

    # lc_set '[ "/bin/login", "-f", "root" ]'
    # lc_current="$(lc_get)"
    # echo "current launch cmd: $lc_current"
}

#===============================================================
#
#
#       hostname method
#
#
#===============================================================
install_f_hostname_alt() {
    echo "Enabling alternate hostname $f_hostname_alt"
    cp /opt/AOK/common_AOK/hostname_handling/hostname_alt "$f_hostname_alt"
    chmod 755 "$f_hostname_alt"
}

remove_f_hostname_alt() {
    rm -f "$f_hostname_alt"
}

hostname_do_source() {
    f_src="$1"
    [ -z "$f_src" ] && error_msg "hostname_do_source() - called without parameter"
    echo "Hostname set to: $("$f_hostname_alt" -S "$f_src")"
}

change_hostname_method() {
    # msg_2 "change_hostname_method()"
    requested_method="$1"
    source_file="$2"

    case "$requested_method" in

    "enable")
        if [ -z "$source_file" ]; then
            f_current="$(cat "$f_hostname_source_fname" 2>/dev/null)"
            if [ "$f_current" = "$f_etc_hostname" ]; then
                s_old_value="$(cat "$f_etc_hostname" 2>/dev/null)"
            else
                s_old_value="$f_current"
            fi
            echo "For detailed instructions about creating an iOS hostname Shortcut"
            echo "see /opt/APK/Docs/hostname-shortcut.md"
            echo "Enter a static hostname, or if Shortcut sourcefile should be used"
            echo "start with / and give full path, hit enter to keep the previous setting"

            [ -n "$s_old_value" ] && echo "  $s_old_value"
            read -r s_new_value
            [ -z "$s_old_value" ] && echo

            if [ -z "$s_new_value" ]; then
                if [ -z "$s_old_value" ]; then
                    echo "ERROR: Nothing given and no old value was found"
                    echo "       will not activate $f_hostname_alt"
                    echo "       this can be activated later by doing: aok -H enable"
                    echo
                    remove_f_hostname_alt
                    exit 1
                fi
                s_new_value="$s_old_value"
            fi
        else
            s_new_value="$source_file"
        fi

        if [ "${s_new_value%"${s_new_value#?}"}" = "/" ]; then
            #
            #  Use it as a path
            #
            if [ -f "$s_new_value" ]; then
                install_f_hostname_alt
                echo "hostname will be sourced from: $s_new_value"
                hostname_do_source "$s_new_value"
            else
                echo "ERROR: Aborting install of alternate hostname - File not found: $s_new_value"
                echo "       this can be activated later by doing: aok -H enable"
                echo
                remove_f_hostname_alt
                exit 1
            fi
        else
            #
            #  Use it as old style hostname
            #
            install_f_hostname_alt
            echo "$s_new_value" >"$f_etc_hostname"
            echo "/etc/hostname will be used, so no syncing will be done."
            hostname_do_source "$f_etc_hostname"
        fi

        if [ -z "$source_file" ]; then
            #
            #  source_file would typically only be set during initial deploy
            #  and in that case this disclaimer wont be needed
            #
            echo
            echo "Your shell prompt might have cached the hostname when the session started."
            echo "It will then be updated next time you login."
        fi
        ;;

    "disable")
        if [ -f "$f_hostname_alt" ]; then
            echo "Removing $f_hostname_alt"
            remove_f_hostname_alt
        fi
        ;;

    *)
        echo
        echo "ERROR: Bad param to change_hostname_method: $1"
        exit 1
        ;;

    esac
    # msg_3 "change_hostname_method() - done"
}

display_hostname_method() {
    # msg_2 "display_hostname_method()"
    if [ -f "$f_hostname_alt" ]; then
        echo "Enabled"
    else
        echo "Disabled"
    fi
    # msg_3 "display_hostname_method() - done"
}

#===============================================================
#
#   Main
#
#===============================================================

hide_run_as_root=1 . /opt/AOK/tools/run_as_root.sh
. /opt/AOK/tools/utils.sh

autologin_disabled="disabled"
f_launch_cmd_inttab="/usr/local/sbin/console_via_inittab_notification"
launch_cmd_inttab="[ \"$f_launch_cmd_inttab\" ]"
f_etc_hostname=/etc/hostname

verbose=0
prog_name=$(basename "$0")

while true; do
    case "$1" in

    "" | "-h" | "--help")
        show_help
        ;;

    "-v" | "--verbose")
        if [ "$verbose" -eq 0 ]; then
            echo "===  Enabeling verbose mode  ==="
            verbose=1
            set -x
        else
            echo
            echo "WARNING: Multiple verbose options are ignored"
        fi
        exit 0
        ;;

        # "-c" | "--console")
        #     hostfs_is_devuan && error_msg "console toggle is not supported on Devuan yet"
        #     if [ -n "$2" ]; then
        #         this_fs_is_chrooted && error_msg "Can\t change console mode on chrooted system"
        #         change_console_method "$2" "$3"
        #         shift # get rid of extra option
        #     else
        #         display_console_method
        #     fi
        #     exit 0
        #     ;;

    "-a" | "--autologin")
        if [ -n "$2" ]; then
            # this_fs_is_chrooted && error_msg "Can\t change autologin on chrooted system"
            change_autologin "$2"
            shift # get rid of extra option
        else
            _s="$(display_autologin)"
            if [ "$_s" = "$autologin_disabled" ]; then
                echo "autologin disabled"
            else
                echo "autlogin as username: $_s"
            fi
        fi
        exit 0
        ;;

    "-c" | "--continous")
        if [ -n "$2" ]; then
            this_fs_is_chrooted && error_msg "Can\t change continous on chrooted system"
            change_continous_sessions "$2"
            shift # get rid of extra option
        else
            _s="$(display_continous_sessions)"
            if [ "$_s" = "off" ]; then
                echo "New login prompt after logout on|off"
            else
                echo "autlogin as username: $_s"
            fi
        fi
        exit 0
        ;;

    "-H" | "--hostname")
        if [ -n "$2" ]; then
            change_hostname_method "$2" "$3"
            #
            #  Since we dont know if we got 2 or 3 options
            #  It is not possible to tell if there are more, so exit now
            #
            exit 0
        else
            printf "Current login method: "
            display_hostname_method
        fi
        exit 0
        ;;

    *)
        echo
        echo "ERROR: Bad option: $1"
        echo
        show_help
        ;;

    esac
done
